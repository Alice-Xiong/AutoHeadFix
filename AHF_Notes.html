<!DOCTYPE html>
<HTML>
<head>
<title>Auto Head Fix 3</title>
<META NAME="AUTHOR" CONTENT="Jamie Boyd">
</head><body>
<H1>Notes for AHF version 3</H1>
<h2>Settings</h2>
<p>Cage settings and Experiment settings will no longer be kept in separate files, but will be stored in a single file and loaded together into one dictionary, and used to initialize a single object called task. That way, only one object has to be passed around. Individual variables for things like GPIO pin numbers will not be created, functions will refer to task.GPIOpin. Try to remove disconnect between changing, saving hardware settings in the JSON files and in the task dictionary in the running program.</p>
<p>Every bit of funtionality that needs to save any settings or initialize any data is subclassed from an abstract base class. This is for added flexibility, and to organize all the code along the same lines for better readibility and to reduce code duplication. If all the classes follow the same conventions, they cna be manipulated with the same utility functions, found in AHF_ClassAndDictUtils.py, and the hardware tester functionality can simlpy call the hardware tester function for each class. Even the simple blue light to illuminate the brain has been made into a class and subclassed. It serves as a good example of what is involved. The base class for all AHF classes that follow  the pattern is AHF_Base
<pre>
class AHF_Base (metaclass = ABCMeta):
    """
    Defines conventions for classes used for accesing hardware and doing subtasks in AutoHeadFix code
    Each class has a static method, config_user_get, to create or edit a settings dictionary, and will be inititialized
    with a settings dictionary. The setup function does hardware initialization, or other inititialization. 
    """
    
    @staticmethod
    @abstractmethod
    def about():
        """
        Returns a brief message describing your sub-class, used when asking user to pick a sub-class of this class
        """
        return 'A description of your sub-class goes here'
    
    @staticmethod
    @abstractmethod
    def config_user_get (starterDict = {}):
        """
        static method that querries user for settings, with default responses from starterDict,
        and returns starterDict with settings as edited by the user.

        """
        return starterDict

    
    def newResultsDict (self, starterDict = {}):
        """
        Returns a dictionary with fields, initialized to 0, for storing results from actions of the object, used e.g., by head fixer, stimulator, or rewarder
        not all sub classes may need to return results, so newResultsDict is not an abstract function
        """
        return None
    
    
    def clearResultsDict(self, resultsDict):
        """
        Clears values in the results dictionary, useful when you want daily totals Not all classes may store results, so not an abstract function
        """
        pass


    def individualSettings (self, starterDict = {}):
        """
        Returns starterDict, after adding fields filled with default values that can be modified for individual subjects
         Not all classes may have individualizabe settings, so individualSettings is not an abstract function
        """
        return {}
    

    def __init__(self, taskP, settingsDictP):
        """
        Initialization of a subclass object may be just making a link to the settings dict and running setup
        so this does not need to be an abtract function - your class can use this __init__ as is
        __init__ will be passed both the settings dict andthe entire Task including the settings dict
        Class names need to start with AHF_ and the dictionary must follow convention, named for the class with 'Dict' appended. 
        
        """
        self.task=taskP
        self.settingsDict = settingsDictP
        self.setup ()


    @abstractmethod
    def setup (self):
        """
        does hardware initialization with (possibly updated) info in self.settingsDict
        Run by __init__, or can be run  separately after editing the settingsDict
        """
        pass

    @abstractmethod
    def setdown (self):
        """
        oppposite of setup. Releases any hardware resouces. can be run before editing settings so GPIO
        pins can be reused, for example. This strategy should be used in hardwareTest method, after making changes
        """
        pass

    def __del__ (self):
        """
        For clean up purposes, releases hardware resources with setdown method. Not abstract, sa setdown may be all you need.
        """
        self.setdown ()


    @abstractmethod
    def hardwareTest (self):
        """
        Tests functionality, gives user a chance to change settings. Not restricted to classes that use hardware. Can be used to test any kind of
	functionality or adjust any kind of settings
        """
        pass
</pre>

The base class for functionality to control illumination for imaging is now AHF_BrainLight:
</pre>
from AHF_Base import AHF_Base

class AHF_BrainLight (AHF_Base):

    @abstractmethod
    def onForStim (self):
        """
        Runs when headFixing starts, illuminating the brain or whatever needs illuminating
        """
        pass

    @abstractmethod
    def offForStim (self):
        """
        Runs when headFixing ends, turning off whatever was turned on
        """
        pass
</pre>
The only functions that need to be explicitly added are those that deal explicitly with the job of AHF_BrainLight, namely, turning on and off  lights for illumination. Subclasses of AHF_BrainLight will still need to provide setup, hardwareTest, and other functions, and these must follow the signatures of those described in AHF_Base.

The other classes are organized similarly, with an __init__ that just copies the dictionary, the setup function that actually runs the setup code that does GPIO hardware init, etc. , the config_user_get function that can create a settings dictionary before an object is initialized, and a hardwareTest function that tests the hardware and gives the user a chance to edit the object's settings dictionary, and then runs the setup function. Note that the settings dictionary is created in the Task object, and passed to the __init__ function, which uses the passed in dictionary, not making a fresh copy.  That way, editing the settings through the hardwareTest, for instance, will edit the dictionary that is kept by the Task object. </p>

<p>What experiment information needs to be separate for each mouse? The Stimulator class will define a lot of task specific stuff, each mouse will have an entry for a stimulator dictionary containing information specific to that mouse. Other things:
Reward sizes
number of entry rewards
head-fix proportions
Maybe keep these things in experiment settings as defaults, so if a Mouse is created without these values, it gets the global ones as defaults.</p>
<p>need better management of mouse data within the program, will want to add images, lever position arrays, other non-text data to mouse. pickle or some other serializer thing. Where and how is this data stored? </p>

<h3>Hardware and Task Flexibility with more sub-classable options</h3>
<p>More things are optional, and more hardware is subclassable for different ways of doing things. AHF_HeadFixer, AHF_Rewarder, AHF_Stimulator, AHF_ContactChecker, and AHF_Camera are all base classes that load no harware specific modules. They must be subclassed to do actually do anything.  The base class defines the functions the subclasses must provide, and contain static functions  for getting class names and importing classes, and allowing the user to select one of the subclasses. Each subclass must provide a static function to querry the user for settings, and to return a dictionary with those settings. The subclasses must also specify a test function for use withg the hardWare tester.</p>
<p>
<table cellspacing = "0" cellpadding = "0" border = 1>
<caption>Hardware for AutoHeadFix Systems</caption>
<tbody>
<tr><td>Hardware</td><td>Description</td><td>Is Required?</td><td>Is Subclassed?</td></tr>
<tr><td>HeadFixer</td><td>Stabilizes head for imaging</td><td>No</td><td>Yes</td></tr>
<tr><td>Camera</td><td>Brain imaging camera controlled by Pi</td><td>No</td><td>Yes</td></tr> 
<tr><td>Rewarder</td><td>Provides rewards for training, water droplet, e.g.</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Stimulator</td><td>Controls task-specific hardware during headfix session</td><td>Yes</td><td>Yes</td></tr> 
<tr><td>ContactChecker</td><td>Sgnals that mouse is in position for head fixing or interacting</td><td>Yes</td><td>Yes</td></tr>
<tr><td>TagReader</td><td>Innovations Design RFID reader with tag-in-range pin</td><td>Yes</td><td>No</td></tr>
<tr><td>LickDetector</td><td>Touch sensor based on mpr121 connected to lick port</td><td>No</td><td>No</td></tr>
<tr><td>Brain LED</td><td>SIngle GPIO output that turns on brain illimination LED</td><td>Yes</td><td>Not a Class</td></tr>
</tbody>
</table></p>
<h2>Program Flow Description</h2>
<p>COnfigutation file is loaded or created, task object is created, hardware is initializaed, files for saving data are created. Program enters the top-level loop, waiting on the global variable globalTag to switch from 0. Mouse enters the tube. The tagReader callback reads the tag, and changes global variable globalTag from 0 to the mouse's id. 
<H2>Remote control of AHF program using watchdog (pip3 install watchdog) ?</H2>
</body>
</html>